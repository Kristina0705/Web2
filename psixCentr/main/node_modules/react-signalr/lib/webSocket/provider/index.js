"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFactory = void 0;
const hermes_channel_1 = __importDefault(require("hermes-channel"));
const react_1 = require("react");
const js_cookie_1 = __importDefault(require("js-cookie"));
const utils_1 = require("../utils");
const utils_2 = require("../../utils");
const IS_SIGNAL_R_CONNECTED = "IS_SIGNAL_R_CONNECTED";
const KEY_LAST_CONNECTION_TIME = "KEY_LAST_CONNECTION_TIME";
function providerFactory(context) {
    const Provider = ({ url, connectEnabled = true, children, dependencies = [], onError, onOpen, onClose, logger = utils_2.__DEV__ ? console : null, }) => {
        const onErrorRef = (0, utils_2.usePropRef)(onError);
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const clear = (0, react_1.useRef)(() => { });
        function refreshConnection() {
            var _a;
            if (!connectEnabled) {
                return;
            }
            let lastConnectionSentState = Number(js_cookie_1.default.get(KEY_LAST_CONNECTION_TIME)) || null;
            let anotherTabConnectionId = null;
            /** If another tab connected to signalR we will receive this event */
            hermes_channel_1.default.on(IS_SIGNAL_R_CONNECTED, (_anotherTabConnectionId) => {
                var _a;
                // connected tab will send empty _anotherTabConnectionId before close
                if (!_anotherTabConnectionId) {
                    lastConnectionSentState = null;
                    anotherTabConnectionId = null;
                    checkForStart();
                    return;
                }
                logger === null || logger === void 0 ? void 0 : logger.log("_anotherTabConnectionId");
                anotherTabConnectionId = _anotherTabConnectionId;
                lastConnectionSentState = Date.now();
                if (!(0, utils_1.isConnectionConnecting)(context.connection)) {
                    sentInterval && clearInterval(sentInterval);
                    (_a = context.connection) === null || _a === void 0 ? void 0 : _a.close();
                }
            });
            let sentInterval;
            async function checkForStart() {
                var _a;
                function syncWithTabs() {
                    var _a;
                    if (anotherTabConnectionId) {
                        clearInterval(sentInterval);
                        (_a = context.connection) === null || _a === void 0 ? void 0 : _a.close();
                        return;
                    }
                    shoutConnected(String(context.key));
                }
                logger === null || logger === void 0 ? void 0 : logger.log({
                    lastConnectionSentState,
                    isConnectionConnecting: (0, utils_1.isConnectionConnecting)(context.connection),
                });
                if ((!lastConnectionSentState ||
                    lastConnectionSentState < Date.now() - 5000) &&
                    !(0, utils_1.isConnectionConnecting)(context.connection)) {
                    try {
                        (0, utils_1.createConnection)(context, {
                            onClose,
                            onOpen,
                            logger,
                            url,
                            onErrorRef,
                        });
                        shoutConnected(String(context.key));
                        sentInterval = setInterval(syncWithTabs, 4000);
                        syncWithTabs();
                    }
                    catch (err) {
                        logger === null || logger === void 0 ? void 0 : logger.error(err.message);
                        sentInterval && clearInterval(sentInterval);
                        (_a = onErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onErrorRef, err);
                    }
                }
            }
            checkForStart();
            const checkInterval = setInterval(checkForStart, 6000);
            /**
             * Before of this tab close this event will sent an empty
             * anotherTabConnectionId to other tabs
             */
            function onBeforeunload() {
                var _a;
                if ((0, utils_1.isConnectionConnecting)(context.connection)) {
                    shoutConnected(null);
                    clearInterval(sentInterval);
                    (_a = context.connection) === null || _a === void 0 ? void 0 : _a.close();
                }
            }
            /** AddEventListener is not exist in react-native */
            (_a = window === null || window === void 0 ? void 0 : window.addEventListener) === null || _a === void 0 ? void 0 : _a.call(window, "beforeunload", onBeforeunload);
            clear.current = () => {
                var _a, _b;
                clearInterval(checkInterval);
                sentInterval && clearInterval(sentInterval);
                (_a = context.connection) === null || _a === void 0 ? void 0 : _a.close();
                hermes_channel_1.default.off(IS_SIGNAL_R_CONNECTED);
                /** RemoveEventListener is not exist in react-native */
                (_b = window === null || window === void 0 ? void 0 : window.removeEventListener) === null || _b === void 0 ? void 0 : _b.call(window, "beforeunload", onBeforeunload);
            };
        }
        (0, react_1.useState)(() => {
            refreshConnection();
        });
        const isMounted = (0, react_1.useRef)(false);
        (0, react_1.useEffect)(() => {
            if (isMounted.current) {
                refreshConnection();
            }
            isMounted.current = true;
            return () => {
                clear.current();
            };
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [connectEnabled, url, ...dependencies]);
        return children;
    };
    return Provider;
}
exports.providerFactory = providerFactory;
function shoutConnected(anotherTabConnectionId) {
    if (!anotherTabConnectionId) {
        hermes_channel_1.default.send(IS_SIGNAL_R_CONNECTED, "");
        js_cookie_1.default.set(KEY_LAST_CONNECTION_TIME, "");
        return;
    }
    hermes_channel_1.default.send(IS_SIGNAL_R_CONNECTED, anotherTabConnectionId);
    const expires = new Date();
    expires.setSeconds(expires.getSeconds() + 10);
    js_cookie_1.default.set(KEY_LAST_CONNECTION_TIME, Date.now().toString(), {
        expires,
        path: "/",
    });
}
//# sourceMappingURL=index.js.map