"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFactory = void 0;
const hermes_channel_1 = __importDefault(require("hermes-channel"));
const react_1 = require("react");
const js_cookie_1 = __importDefault(require("js-cookie"));
const utils_1 = require("../utils");
const utils_2 = require("../../utils");
const IS_SIGNAL_R_CONNECTED = "IS_SIGNAL_R_CONNECTED";
const KEY_LAST_CONNECTION_TIME = "KEY_LAST_CONNECTION_TIME";
function providerFactory(Context) {
    const Provider = ({ url, connectEnabled = true, children, dependencies = [], accessTokenFactory, onError, onOpen, onReconnect, onClosed, onBeforeClose, logger, ...rest }) => {
        const onErrorRef = (0, utils_2.usePropRef)(onError);
        const accessTokenFactoryRef = (0, utils_2.usePropRef)(accessTokenFactory);
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const clear = (0, react_1.useRef)(() => { });
        function refreshConnection() {
            var _a;
            if (!connectEnabled) {
                return;
            }
            const connection = (0, utils_1.createConnection)(url, {
                accessTokenFactory: () => { var _a; return ((_a = accessTokenFactoryRef.current) === null || _a === void 0 ? void 0 : _a.call(accessTokenFactoryRef)) || ""; },
                logger,
                ...rest,
            });
            connection.onreconnecting((error) => { var _a; return (_a = onErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onErrorRef, error); });
            connection.onreconnected(() => onReconnect === null || onReconnect === void 0 ? void 0 : onReconnect(connection));
            Context.connection = connection;
            //@ts-ignore
            Context.reOn();
            connection.onclose((error) => {
                onClosed === null || onClosed === void 0 ? void 0 : onClosed(error);
            });
            let lastConnectionSentState = Number(js_cookie_1.default.get(KEY_LAST_CONNECTION_TIME)) || null;
            let anotherTabConnectionId = null;
            /** If another tab connected to signalR we will receive this event */
            hermes_channel_1.default.on(IS_SIGNAL_R_CONNECTED, (_anotherTabConnectionId) => {
                // connected tab will send empty _anotherTabConnectionId before close
                if (!_anotherTabConnectionId) {
                    lastConnectionSentState = null;
                    anotherTabConnectionId = null;
                    checkForStart();
                    return;
                }
                if (logger) {
                    console.log("Another tab connected");
                }
                anotherTabConnectionId = _anotherTabConnectionId;
                lastConnectionSentState = Date.now();
                if (!(0, utils_1.isConnectionConnecting)(connection)) {
                    sentInterval && clearInterval(sentInterval);
                    connection.stop();
                }
            });
            let sentInterval;
            async function checkForStart() {
                var _a;
                function syncWithTabs() {
                    if (anotherTabConnectionId) {
                        clearInterval(sentInterval);
                        connection.stop();
                        return;
                    }
                    shoutConnected(connection.connectionId);
                }
                if ((!lastConnectionSentState ||
                    lastConnectionSentState < Date.now() - 5000) &&
                    !(0, utils_1.isConnectionConnecting)(connection)) {
                    try {
                        shoutConnected(connection.connectionId);
                        await connection.start();
                        onOpen === null || onOpen === void 0 ? void 0 : onOpen(connection);
                        sentInterval = setInterval(syncWithTabs, 4000);
                        syncWithTabs();
                    }
                    catch (err) {
                        console.log(err);
                        sentInterval && clearInterval(sentInterval);
                        (_a = onErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onErrorRef, err);
                    }
                }
            }
            checkForStart();
            const checkInterval = setInterval(checkForStart, 6000);
            /**
             * Before of this tab close this event will sent an empty
             * anotherTabConnectionId to other tabs
             */
            function onBeforeunload() {
                if ((0, utils_1.isConnectionConnecting)(connection)) {
                    shoutConnected(null);
                    clearInterval(sentInterval);
                    connection.stop();
                }
            }
            /** AddEventListener is not exist in react-native */
            (_a = window === null || window === void 0 ? void 0 : window.addEventListener) === null || _a === void 0 ? void 0 : _a.call(window, "beforeunload", onBeforeunload);
            clear.current = async () => {
                var _a;
                clearInterval(checkInterval);
                sentInterval && clearInterval(sentInterval);
                await (onBeforeClose === null || onBeforeClose === void 0 ? void 0 : onBeforeClose(connection));
                connection.stop();
                hermes_channel_1.default.off(IS_SIGNAL_R_CONNECTED);
                /** RemoveEventListener is not exist in react-native */
                (_a = window === null || window === void 0 ? void 0 : window.removeEventListener) === null || _a === void 0 ? void 0 : _a.call(window, "beforeunload", onBeforeunload);
            };
        }
        (0, react_1.useState)(() => {
            refreshConnection();
        });
        const isMounted = (0, react_1.useRef)(false);
        (0, react_1.useEffect)(() => {
            if (isMounted.current) {
                refreshConnection();
            }
            isMounted.current = true;
            return () => {
                clear.current();
            };
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [connectEnabled, url, ...dependencies]);
        return children;
    };
    return Provider;
}
exports.providerFactory = providerFactory;
function shoutConnected(anotherTabConnectionId) {
    if (!anotherTabConnectionId) {
        hermes_channel_1.default.send(IS_SIGNAL_R_CONNECTED, "");
        js_cookie_1.default.set(KEY_LAST_CONNECTION_TIME, "");
        return;
    }
    hermes_channel_1.default.send(IS_SIGNAL_R_CONNECTED, anotherTabConnectionId);
    const expires = new Date();
    expires.setSeconds(expires.getSeconds() + 10);
    js_cookie_1.default.set(KEY_LAST_CONNECTION_TIME, Date.now().toString(), {
        expires,
        path: "/",
    });
}
//# sourceMappingURL=index.js.map